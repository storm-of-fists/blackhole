# README

Nucleus is a small, opinionated, Rust framework meant to standardize program state and its modification.

## Parts

Nucleus has 3 major parts: Nucleus, State, and Updater. A Nucleus contains stores for state and updaters. State contains program data. Updaters manipulate state or other updaters.

### Nucleus

The nucleus is where you start your program. Usually the only two things you do to the nucleus directly are adding updaters and running the nucleus. The nucleus "runs" by looping over each updater continuously.

### State

State is added/acquired/removed from a StateStore. You can register "thread-local state" or "shared state" that can be accessed across thread boundaries. State is a thin wrapper around Rc<RefCell\<T>\>, providing only specific APIs to prevent blocking. Shared state is a thin wrapper around Arc<Mutex\<T>\>.

State and shared state are stored in their own HashMaps, with the key being their TypeId's. If multithreading is added to your program, each new nucleus that is spawned will get a copy of the shared state created by the first nucleus.

### Updater

Updaters are trait objects stored in a vector. Each contains only a State or SharedState of what they need for their update method.

## Philosophy

I was inspired to make it because I want to do more projects in Rust, but I wanted a "simple at its core" framework.

I was trying to avoid:

- Async.
- Complicated updater scheduling/lifecycle.
- Context pointers.
- Deeply nested or deeply composed state.
- Hidden state.
- Message passing.
- Abstraction of the work cycle.

### Chosen Unimplemented

- Advanced scheduler for updaters
- "Modding" system for runtime loading of new threads/updaters/state. I figured this is going to be very user dependent. I also didn't want to burden the central framework with it.

## Benchmarks and Tests

I also wanted the framework to be easily testable. Updaters can be enabled/disabled as needed. A user that wants to test a certain plugin can load it, then replace any updaters with their own test updaters.

## Open Questions

1. Switch away from using TypeId and use names instead. TypeId changes based on rust release, but is constant with the rust version from what I cant tell. Test how type casting works more, especially with loaded libraries. Would really like to support loading things at runtime.
