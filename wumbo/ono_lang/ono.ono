[ # TODOs
    - Do I want the concept of macros or is it fine to keep as function?
    - Do I want interior types to be marked like Option-[ Some-Type ]? It feels like a copout.
    - What does template rendering look like? Preferably like jinja in some way.
    - Should namespaces always required accessing interior objects like Namespace-[ Interior ]
        - Then lets us call objects with interior types 'Namespaces' and access them like Option-[ Interior ]
    - Use UCUM for units, include those in the library https://ucum.org/ucum
    - update to use actual quotations for strings, not more brackets
    - i want ono to be open source and only take donations.
]

[ # Philosophizing
    Code executes in CONTEXTS. CONTEXTS are specified by an open square bracket and a close square bracket [].
    Values 'fall' out of CONTEXTS if there is only 1 CONTEXT or VALUE within it. Otherwise, a [ return ] statement is required.
    Code lives in LIBRARIES.
    Code runs in scopes []. Similar to rust. The last values in the scope are implicitly returned. Can also be explicit. So [true] and [[return true]] both return a value of true.
    LIBRARIES can depend on other LIBRARIES.
    LIBRARIES can be assembled into BINARIES.
    BINARIES can be grouped into DEPLOYMENTS.
    LIBRARIES contain DATA, FUNCTIONS.
    LIBRARIES and DATA "namespace" FUNCTIONS. DATA instances also namespace implicitly, so member FUNCTION calls are written in the same order as static FUNCTIONS, like [data-instance function-name arg] or [Data-Name function-name arg]
    FUNCTIONS use prefix notation.
    FUNCTIONS act on DATA to return other DATA.
    DATA is just a model of some real process or data. Remember that it will contain assumptions, like mathematical models. You're DATA could be perfectly fine, but your model is making bad assumptions.
    Instances of DATA are named like 'my-data-instance'. Types are named like 'My-Type-Name'. These are the only two naming conventions. Nothing else is allowed. Ono will not let a program compile unless this is met.
    FUNCTIONS, DATA, ENUMERATIONS, and other functions utilize FIELDS for specifying inputs/member data.
    FIELDS have common arguments/keyword arguments. Sometimes these are filled in by FUNCTIONS.
    The language makes heavy use of TEMPLATING.
    Author source code in TEMPLATES. Review rendered code. That's what runs. Use the CLI to render code easily.
    Utilize test driven development.
    Use long names for things.
    Ono has two runtime modes. Relaxed mode uses Just In Time compilation, runtime typing, adds metadata to instances of DATA, and allocates non-primitive DATA types unless explicitly told not to.
    Strict mode enforces DATA typing on function calls, applies essentially no runtime overhead, and does not allocate unless explicitly told to.
    Ono can mix runtime modes. A relaxed runtime will be linked with any compiled strict LIBRARIES. This will then start and load relaxed libraries into the runtime.
    Ono, wherever possible, makes use of settings for something instead of coming up with a new term or name.
    Ono attempts to expose documentation and settings with 1 or less commands in the cli.
    Ono attempts to stay as flat as possible.
    Values "fall" out of scopes if there is only 1
]

[ # Libraries
    Here is the Examples library, which contains a variety of examples of the
    Ono language. You can see the 'library' function call. The first argument
    is a String, but you don't need to use quotes. Just type it. There can only
    be one library per file.

    You'll also see keyword arguments being passed to the module. Note these
    are before the required argument of the code logic. You just need to ensure
    arguments are in the right order and you can mix keyword arguments throughout.

    This library can be compiled into a linkable object via the cli tool:
    'ono [ compile-library Examples ]'.

    There are two runtime modes: relaxed and strict.
    The relaxed mode is just in time compiled, defaults to allocating non-primitives, always assumes
    something is of 64 bit size [primitives and references to the allocations] and doesn't type
    check. The strict mode disables garbage collection, has strong [static] type checking,
    and disables automatic allocation.

    Feel free to mix strongly type checked and non-allocating code with the just in time
    compiled and garbage collected libraries. You do not need to worry about complicated
    interface settings. If any libraries utilize the JIT compiler, they will run with that runtime.
    libraries that are compiled prior to runtime will stay compiled and are included with the JIT runtime
    as object files that are then turned into a single executable.

    The automatic allocation mode for libraries also includes an additional metadata field
    describing information about the object, similar to python or javascript. This can
    be disabled if not needed.

    I wanted this language to be translatable. People can distribute "alias" packs that simply
    transform the data types, functions, and macros from one set of UTF-8 symbols to another.
    Users can then depend on those libraries with some language setting.
]
[ library Examples
    visibility-[ test ]
    run-mode-[ relaxed ]
    [ # Formatting
        The CLI tool will do formatting for you, but best practice is to
        have a space after the opening and before the closing brackets.
        I just think it's easier to read.

        Comments have a space after them. Function and contract definitions have
        a space after them. Try to keep code thin. Kwargs are on a newline.
    ]

    [ # Comments
        Note how the code calls the comment function, and you provide a title
        and then the text for the comment. You do not need a title.
    ]

    [ # The Use Macro
        The 'use' macro lets you use parts of other Modules. Ono will then do the work
        of figuring out the dependency graph.
    ]

    [ use Std [ Map Buffer ] ]
    [ use Core [ bind function data enum ] ]

    [ # Functions
        Ah, a good ole function just as we programmers know it. Marked with the
        public visibility. Functions can have private (default), library, or public
        visibilities.

        Next come fields. These are the arguments to the function. The field function
        is used in Data definitions also to simplify.

        The required arguments for a function are 'name', 'return type', 'fields*', and
        the actual logic inside of a context [].

        There are also keyword arguments that specify things like visibility. There are
        many more keyword arguments to functions and some of them are not compatible. Ono
        will let you know when you go to compile.

        This function simply takes 2 float-32's, one of them by default being 12.0, and
        adds them. A single top level context will return by itself, but multiple contexts
        need a [return] statement. This is so keyword arguments always return from their context.

        So this requires a return statement
        [
            [ bind foo [ add 2 3 ] ]
            [ bind bar [ add 4 5 ] ]

            [ return [ add foo bar ] ]
        ]

        But this does not [ [ add 2 3 ] ]

        [ print [ floating-point-operation 12.0 ] ] prints '24.0' to stdout
        [ print [ floating-point-operation 12.0 argument-2-[ 10.0 ] ] ] prints '22.0' to stdout

        By default the semantics for fields are move, but this can be
        made explicit via arguments in the field function. Then when the function
        is invoked, it is explicit what will happen to the data.

        By default, arguments are immutable, but can be made mutable via the
        argument.
    ]
    [ function floating-point-operation
        returns-[ Floating-Point-32 ]
        visibility-[ public ]
        [ field argument-1 Floating-Point-32 semantics-[ move ] mutable-[ true ] ]
        [ field argument-2 Floating-Point-32 default-[ 12.0 ] semantics-[ copy ] ]
        [
            [ add argument-1 argument-2 ]
        ]
    ]

    [ # Macros
        Here is an example of a Macro. It is a function whose definition is
        marked with a kwarg called macro. By default it is false.
    ]
    [ function my-fun-macro
        returns-[ Ono-Code ]
        macro-[ true ]
        visibility-[ public ]
        [
            [ Ono-Code-[ from-string ] '[ bind [ my-var 3.0 ] ]' ]
        ]
    ]

    [ # Info On Fields
        Field function calls allow users to specify an 'info' keyword argument.
        This info will be displayed by the ono cli when inspecting the function.
        The info will also be shown if the function is being called as the entry
        point to the program, like other programs, if you say ono [ help 'function-name' ].
    ]
    [ function main
        [ field create-map Boolean info-[ Whether or not to create a map. ] ]
        [ field create-buffer Boolean default-[ true ] info-[ Whether to create a buffer or not. ] ]
        [
            [ bind my-map [ Map-new 50 type-[ btree ] ] ]
            [ bind my-buffer [ Buffer-new 50 allocated-[ true ] auto-grow-[ true ] ] ]
            [ bind int 0 ]
            [ loop
                name-[ foo ]
                [
                    [ mutate int [ add int 1 ] ]

                    [ if [ greater-than int 10 ] [
                        [ # Loop Breaks
                            You can specify a specific loop to break from.

                            You can also use [ continue name-[ foo ] ]
                        ]
                        [ break name-[ foo ] ]
                    ]
                ]
            ] ]


            [ return ]
        ]
    ]

    [ # Binaries
        Use the binary macro to declare a binary to be run. This can then be called
        using the ono CLI: 'ono [ run-binary My-Example-Binary ]'.

        Binaries need to be declared in the same library that the entry point lives.
        Main functions are the typical entrypoint for a program. They do not need to be
        called 'main', as binaries are defined explicitly (as seen below).

        Main functions can have fields, same as any other function. These fields are exposed
        as command line arguments when used as a main function. So this main function would be
        called like ono [ My-Example-Binary false create-buffer-[ false ] ].

        The second binary definition supplies some of the arguments to the program, but not all.
        That program could be called like ono [ My-Other-Binary false ] and it'd be functionally
        equivalent to ono [ My-Example-Binary false create-buffer-[ false ] ].

        This ability to write binaries like this, as well as create macros that expand before compile
        allows users to do configuration management inside of ono. You should not need a different
        file format. If you do, you're not using ono like it's meant to be used.

        Binaries are by default built with debug information included in the binary. These can be
        stripped with debug-[ false ].

        Because a binary is not a namespace, it is not capitalized.
    ]
    [ binary my-example-binary main ]
    [ binary my-other-binary main
        arguments-[ create-buffer-[ false ] ] debug-[ false ]
    ]

    [ # Enumerations
        Enumerations also use the field function in order to define their variants.
        The enumeration is a 'union', in that the size of the enumeration will be
        the size of the largest variant.

        When the default value is left unspecified, the enum function by default
        will specify a unique value for each variant. In this case, it would set
        variant-0 to 0, variant-1 to 1, and variant-2 to 2. This only works for
        values that satisfy the Default contract.

        Enums can also have different types per value, similar to Rust. See Bar-Enum.
        The size of the enum is the size of the largest type.

        You can also specify a type at the enum level. It will default to
        Unsigned-Integer-8 and change to fit more variants
    ]
    [ enum Foo-Enum
        type-[ Floating-Point-32 ]
        [ field variant-0 ]
        [ field variant-1 ]
        [ field variant-2 ]
    ]

    [ enum Bar-Enum
        [ field variant-0 Unsigned-Integer-8 ]
        [ field variant-1 Unsigned-Integer-16 ]
        [ field variant-2 Unsigned-Integer-32 ]
    ]

    [ # Contracts

    ]
    [ contract My-Contract
        [ field field-one Floating-Point-32
            visibility-[ private ]
            default-[ 12.0 ]
        ]

        [ function field-two Floating-Point-32
            visibility-[ public ]
            [
                [ multiply-f32 2.0 field-one ]
            ]
        ]

        [ function add-to-field-one
            inline-[ true ]
            [
                [ increment field-one 1 ]
            ]
        ]
    ]

    [ # Cache
        Functions can automatically create caches. Users can set the size of
        the cache and the retrieval function. By default it just compares byte
        values.

        If you use Function-Cache-default, you can specify a size. If there is no
        size specified, the cache will just continue to grow.
    ]
    [ function cached-function
        cache-[ Function-Cache-[ default ] size-[ 10 ] ]
    ]
]

[ library Primitives
    visibility-[ external ]
    [
        [ # Primitives ]
        Unsigned-Integer-[ 8 16 32 64 128 ]
        Signed-Integer-[ 8 16 32 64 128 ]
        Floating-Point-[ 8 16 32 64 ]
        Boolean
        AllocatedString
        SizedString
        Character
        StackError
        HeapError

        [ # Templated Types ]
        Tuple-[ T T T ]
        Option-[ T ]
        Result-[ T ]
        Array-[ T Option-[ u64 ] ] [ # a Array with size of none will be allocated and growable. ]
        Pointer-[ inner-[ T ] ]
        Reference-[ inner-[ T ] mutable-[ Boolean ] ]
        Map[ key-[ T ] value-[ T ] ]

        [ # The Big Three Macros
            The Big Three Macros you see the most of are function, contract, and field.

            Field is a singular piece of data of some shape. It can contain more information
            such as unit (a sort of type constriction), info for context about why it exists,
            and more. When you use the Ono-Data-Type type, that is a special type constructed
            at build time that is one of any of the types found in the Library or imported from
            other libraries.

            Function is something that acts on data.
        ]
        [ function field
            macro-[ true ]
            [ field name String-[ size-[ 50 ] ] ]
            [ field data-type Ono-Data-Type ]
        ]

        [ function function
            [ field name String-[ size-[ 50 ] ] ]
            [ field macro Boolean default-[ true ] ]
            [ field cache Option-[ FunctionCache ] default-[ none ] ]
            rest-of-fields-bind-to-[ [ field fields Vector-[ Ono-Field ] ]
        ]


        [ function bind
            [ field name String-[ size-[ 50 ] ] ]
            [ field value Any ]
            [
                TBD
            ]
        ]

        [ function mutate
            [ field name ]

        allocate
        pin

        oneof
        match

        copy
        move
        reference

        [ # Looping
            Here are some helpful
        ]
        [ function loop
            macro-[ true ]
            [ field name Option-[ String ] default-[ none ] ]
            [
                TBD
            ]
        ]

        [ function break
            macro-[ true ]
            [ field name Option-[ String ] default-[ none ] ]
            [
                TBD
            ]
        ]

        [ function continue
            macro-[ true ]
            [ field name Option-[ String ] default-[ none ] ]
            [
                TBD
            ]
        ]

        return

        compose
    ]
]

[ library Ono-Types
    info-[
        These types are what actually make up blocks of code.
    ]
    [ contract Ono-Common-Fields
        [ field name String
            max-len-[ 50 ] [ # TBD on this kwarg or how we specify it for a string. ]
            info-[ The name of the item. Keep it short! ]
        ]

        [ field visibility Visibility
            default-[ private ]
            info-[
                At what level this item is visible. Does not apply to visibility-[ test ]
                items that depend on it.

                An item with test visibility can only be depended on by other
                items marked test visibility. So a test library can be used by
                another test library, but a binary cannot use a test library.
            ]
        ]
    ]

    [ contract Ono-Contract
        [ field fields Vector-[ Ono-Field ] max-len-[ 10 ] ]
        [ field memory-padding Boolean default-[ true ] ]

        [ compose Ono-Common-Fields ]

        [ compose Static-Size
            [ # Overriding Fields
                You can override each field of the field. In this case, we don't
                override 'info', so it will stay the same.
            ]
            [ field some-actual-field Unsigned-Integer-64
                default-[ 5 ]
            ]

            [ # Implementing Virtual Functions
                You must implement the virtual functions of the contract being
                composed in order to satisfy it.
            ]
            [ function size Unsigned-Integer-64
                [
                    [ sum fields  ]
                ]
            ]
        ]
    ]

    [ contract Ono-Library
        info-[
            This contract is one of the core pieces of the Ono code model.
        ]
        [ field aliases Option-[ Map-[ String String ] ]
            default-[ none ]
        ]
        [ field runtime-mode Runtime-Mode
            default-[ strict ]
        ]
        [ field recursion-allowed Boolean
            default-[ false ]
        ]
        [ field float-inference Option-[ [ oneof Floating-Point-64 Floating-Point-32 ] ]
            default-[ none ]
        ]
        [ field signed-integer-inference Option-[ [ oneof Signed-Integer-8 Signed-Integer-16 Signed-Integer-32 Signed-Integer-64 ] ]
            default-[ none ]
        ]
        [ field unsigned-integer-inference Option-[ [ oneof Unsigned-Integer-64 Unsigned-Integer-64 Unsigned-Integer-64 Unsigned-Integer-64 ] ]
            default-[ none ]
        ]
        [ field garbage-collect-rate Option-[ Unsigned-Integer-64 ]
            default-[ none ]
            can-be-set-if-[ [ not [ equals runtime-mode relaxed ] ] ]
        ]
        [ field always-allocate Boolean
            default-[ false ]
        ]
        [ field allow-allocation Boolean
            default-[ true ]
        ]
        [ field allocation-batching-cycle Option-[ Duration ]
            default-[ none ]
            info-[
                If you want to batch allocations together.
                TODO: is this viable?
            ]
        ]
        [ field max-function-call-depth Option-[ Unsigned-Integer-64 ]
            info-[
                If you will only allow a certain amount of nesting. Compiler
                yells at you if you go over this.
            ]
            default-[ none ]
        ]

        [ field functions Vector-Ono-Function
            info-[ The different contracts defined in this library. ]
        ]

        [ field contracts Vector-Ono-Contract
            info-[ The different contracts defined in this library. ]
        ]

        [ compose Ono-Common-Fields ]
    ]

    [ contract Ono-Binary
        info-[ This contract is one of the core pieces of the Ono code model. ]

        [ field libraries Vector-Ono-Library
            info-[ The libraries that compose this binary. ]
        ]

        [ field max-call-stack-size Option-[ u32 ]
            info-[ Set the maximum call stack size before ending the process. ]
            default-[ none ]
        ]

        [ compose Ono-Common-Fields ]
    ]

    [ contract Ono-Field
        info-[]

        [ # Composing
            Composing allows you to have similar fields without the need
            to nested compose objects or inherit from them. This is really just
            a macro that takes the fields of the contract being composed and puts
            them in this contract.
        ]
        [ compose Ono-Common-Fields ]


        [ compose Static-Size
            [ function size Unsigned-Integer-64
                [ data-type-size ]
            ]
        ]
        [ # TODO: cant use field here, since this what we are describing.
            We will need to use primitives some other way.
        ]
        [ field data-type Option-[ Ono-Data-Type ]
            default-[ none ]
            info-[
                This is the data type that we expect this field to have.
            ]
        ]
    ]

    [ contract Ono-Function
        info-[ This contract is one of the core pieces of the Ono code model. ]

        [ compose Ono-Common-Fields ]

        [ field fields Vector-[ Ono-Field ]
            default-[ Vec-empty ]
            info-[
                The different input fields that allow the function to satisfy
                its returns contract.
            ]
        ]

        [ field returns Option-[ Ono-Data-Type ]
            default-[ none ]
            info-[
                The type of contract this function will satisfy when called.
            ]
        ]

        [ field inline Boolean
            default-[ false ]
            info-[
                Whether or not to inline this function every call. Typically
                only used with smaller functions.
            ]
        ]

        [ field macro Boolean
            default-[ false ]
            info-[
                If this function is going to be evaluated as part of the
                compilation process.
            ]
        ]

        [ field expansion-order Option-[ Signed-Integer-32 ]
            default-[ true ]
            info-[
                If this is a macro, whether or not this macro should expand before
                or after its parent macro context.

                This allows for macros that can inspect and make 'decisions' based
                on the context of code around them.

                TODO: is this real? do we need this? Need to inspect macro expansion
                flow better. Maybe we just do it with relative numbers.
            ]
        ]

        [ field static Boolean
            default-[ false ]
            info-[
                If this is a static function whose output value will be known at
                compile time.

                TODO: could maybe use like compile-time/macro for this?
                TODO: lets use a more clear term for this.
            ]
        ]
    ]
]

[ library Enum
    [ function enum Ono-Code
        macro-[ true ]
        [ # Collecting Repeated Fields
            repeated-fields allows as many arguments as desired to be captured.
            Because this is not knowable until this function is executed, the
            Array backing the variants field is able to grow dynamically.

            collects-repeated-fields requires the user to specify which field
            of the function will collect the values.

            Just because this macro will
        ]
        collects-repeated-fields-[ variants ]
        [ field variants Array-[ Ono-Field ] ]

        [
            [ template [

            ] ]
        ]
    ]
]

[ library Static-Size
    [ contract Static-Size
        [ field some-actual-field Unsigned-Integer-64
            default-[ 10 ]
            info-[
                Here is an example where we have a mix of state and functions as
                part of this contract. When composed, the state can be overwritten
                or left as is.
            ]
        ]
        [ function size Unsigned-Integer-64
            info-[
                Here is a purely virtual function that must be implemented by
                a contract in order to satisfy this contract.
            ]
            static-[ true ]
            virtual-[ true ]
        ]
    ]
]

[ library Core
    [ use Enum-[ enum ] ]

    [ enum Visibility
        visibility-[ external ]

        [ field test ]
        [ field private ]
        [ field library ]
        [ field binary ]
        [ field external ]
    ]
]

[ library Template
    [ function template returns-[ Result-[ String ] ]
        [ field template-string String ]

        repeated-fields-gather-into-[ template-replacements ]
        [ field template-replacements Config ]

        replacement-string-[ '{ * }' ]

        [
            [ # Template Strings
                '[ bind { [ if true 1 else-[ 2 ] ] } ]' the code inside the {  } will be
                executed when the template is rendered. Other code in the string will not.

                This is similar to jinja, but we don't need different 'replace' and 'statement'
                symbols due to ono dropping values out of contexts. You can use
            ]

            [ bind matches [ String-[ find-matches ] template-string '{ }' ] ]
        ]
    ]

    [ # Templating Views
        [ type Ono-Non-Namespace-Name String-[ length-[ 50 ] ] ]

        [ contract String

        ]


        [ template
            '
            [ contract SizedString-{ T }
                [ field characters Array-[ Utf-8-Character ] ]
                [ field size Unsigned-Integer-64 ]
            ]
            '
        ]

        [ template
            [ field T Unsigned-Integer-64 ]
            [
                [ contract Sized-String-{ T }

            ]
        ]


        ]

        [ contract AllocatedString
            [ field char-array Array-[ Utf-8-Character ] ]
            [ field size Unsigned-Integer-64 ]
        ]

        [ contract String
            [ function sized
                returns-[ SizedString ]

            ]
            [ function allocated
                returns-[ AllocatedString ]

            ]
        ]
    ]
]







