[ comment Libraries
    Here is the Examples library, which contains a variety of examples of the
    Ono language. You can see the 'library' function call. The first argument
    is a String, but you don't need to use quotes. Just type it. There can only
    be one library per file.

    You'll also see keyword arguments being passed to the module. Note these
    are before the required argument of the code logic. You just need to ensure
    arguments are in the right order and you can mix keyword arguments throughout.

    The run-mode is set to 0. This is the default value but it's explicit here
    to show that this module is statically typed and compiled to a shared object.

    This library can be compiled into a linkable object via the cli tool:
    'ono [ compile-library Examples ]'.
]

[ library Examples
    run-mode-[ 0 ]
    [

    [ comment Capitalization
        Notice how namespaces are capitalized and functions are not.
    ]

    [ comment Formatting
        The CLI tool will do formatting for you, but best practice is to
        have a space after the opening and before the closing brackets.
        I just think it's easier to read.

        Comments have a space after them. Function and contract definitions have
        a space after them. Try to keep code thin. Kwargs are on a newline.
    ]

    [ comment Comments
        Note how the code calls the comment function, and you provide a title
        and then the text for the comment. You do not need a title.
    ]

    [ comment The Use Macro
        The 'use' macro lets you use parts of other Modules. Ono will then do the work
        of figuring out the dependency graph.
    ]

    [ comment Std and Core
        We want to take over the world, so Ono tries to only ever use precisely what
        you need.
    ]

    [ use Std [ Map Buffer ] ]
    [ use Core [ bind function data enum ] ]

    [ comment Functions
        Ah, a good ole function just as we programmers know it. Marked with the
        public visibility. Functions can have private (default), library, or public
        visibilities.

        Next come fields. These are the arguments to the function. The field function
        is used in Data definitions also to simplify.

        The required arguments for a function are 'name', 'return type', 'fields*', and
        the actual logic inside of a context [].

        There are also keyword arguments that specify things like visibility. There are
        many more keyword arguments to functions and some of them are not compatible. Ono
        will let you know when you go to compile.

        This function simply takes 2 float-32's, one of them by default being 12.0, and
        adds them. A single top level context will return by itself, but multiple contexts
        need a [return] statement. This is so keyword arguments always return from their context.

        So this requires a return statement
        [
            [ bind foo [ add 2 3 ] ]
            [ bind bar [ add 4 5 ] ]

            [ return [ add foo bar ] ]
        ]

        But this does not [ [ add 2 3 ] ]

        [ print [ floating-point-operation 12.0 ] ] prints '24.0' to stdout
        [ print [ floating-point-operation 12.0 argument-2-[ 10.0 ] ] ] prints '22.0' to stdout

        By default the semantics for fields are move, but this can be
        made explicit via arguments in the field function. Then when the function
        is invoked, it is explicit what will happen to the data.

        By default, arguments are immutable, but can be made mutable via the
        argument.
    ]
    [ function floating-point-operation
        returns-[ Floating-Point-32 ]
        visibility-[ public ]
        [ field argument-1 Floating-Point-32 semantics-[ move ] mutable-[ true ] ]
        [ field argument-2 Floating-Point-32 default-[ 12.0 ] semantics-[ copy ] ]
        [
            [add argument-1 argument-2]
        ]
    ]

    [ comment Macros
        Here is an example of a Macro. It is a function whose definition is
        marked with a kwarg called macro. By default it is false.
    ]
    [ function my-fun-macro
        returns-[ Ono-Code ]
        macro-[ true ]
        visibility-[ public ]
        [
            [ Ono-Code-from-string [ bind [ my-var 3.0 ] ] ]
        ]
    ]

    [ function main
        [ field create-map Boolean description-[ Whether or not to create a map. ]]
        [ field create-buffer Boolean default-[ true ] description-[ Whether to create a buffer or not. ] ]
        [
            [ bind my-map [ Map-new 50 type-[ btree ] ] ]
            [ bind my-buffer [ Buffer-new 50 allocated-[ true ] auto-grow-[ true ] ] ]
            [ return ]
        ]
    ]

    [ comment Binaries
        Use the binary macro to declare a binary to be run. This can then be called
        using the ono CLI: 'ono [ run-binary My-Example-Binary ]'.

        Binaries need to be declared in the same library that the entry point lives.
        Main functions are the typical entrypoint for a program. They do not need to be
        called 'main', as binaries are defined explicitly (as seen below).

        Main functions can have fields, same as any other function. These fields are exposed
        as command line arguments when used as a main function. So this main function would be
        called like ono [ My-Example-Binary false create-buffer-[ false ] ].

        The second binary definition supplies some of the arguments to the program, but not all.
        That program could be called like ono [ My-Other-Binary false ] and it'd be functionally
        equivalent to ono [ My-Example-Binary false create-buffer-[ false ] ].

        This ability to write binaries like this, as well as create macros that expand before compile
        allows users to do configuration management inside of ono. You should not need a different
        file format. If you do, you're not using ono like it's meant to be used.
    ]
    [ binary My-Example-Binary main ]
    [ binary My-Other-Binary main arguments-[ create-buffer-[ false ] ] ]
] ]








